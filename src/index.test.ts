import awsSdk from 'aws-sdk';
import Orm from '.';

jest.useFakeTimers();
jest.mock('aws-sdk');

const { DynamoDB } = awsSdk as any;

describe('Database(options)', () => {
  beforeEach(() => {
    // Clear all instances and calls to constructor and all methods:
    DynamoDB.mockClear();
  });

  it('makes the constructor call to dynamodb from aws-sdk', () => {
    new Orm({ getId: () => '2', tableName: 'table', region: 'usa' });
    expect(DynamoDB.DocumentClient).toHaveBeenCalledTimes(1);
  });

  describe('query(query, options)', () => {
    it('calls the dynamo scan once if given a small valid query', async () => {
      const db = await new Orm({ getId: () => '2', tableName: 'table', region: 'usa' });

      const mockedScan = <jest.Mock<typeof DynamoDB.DocumentClient.scan>>db.client.scan;
      mockedScan.mockReturnValue({
        promise: () =>
          Promise.resolve({
            Items: [],
          }),
      });

      const results = await db.query({ name: ['floob', 'flab'] });
      expect(mockedScan).toHaveBeenCalledTimes(1);
      expect(mockedScan).toHaveBeenCalledWith({
        ExpressionAttributeNames: {
          '#name': 'name',
        },
        ExpressionAttributeValues: {
          ':name0': 'floob',
          ':name1': 'flab',
        },
        FilterExpression: '#name IN (:name0, :name1)',
        ReturnConsumedCapacity: 'TOTAL',
        ScanIndexForward: true,
        Select: 'ALL_ATTRIBUTES',
        TableName: 'table',
      });
      expect(results).toEqual([]);
    });

    it('splits out 100+ arrays into multiple calls to bypass scan limit', async () => {
      const db = await new Orm({ getId: () => '2', tableName: 'table', region: 'usa' });

      const mockedScan = <jest.Mock<typeof DynamoDB.DocumentClient.scan>>db.client.scan;
      mockedScan.mockReturnValue({
        promise: () =>
          Promise.resolve({
            Items: [{ name: 'niner' }],
            ConsumedCapacity: { CapacityUnits: 1 },
          }),
      });

      const results = await db.query(
        { name: Array.from({ length: 145 }, () => 'niner') },
        { withMetadata: true }
      );
      expect(mockedScan).toHaveBeenCalledTimes(2);
      expect(results).toEqual({
        items: [{ name: 'niner' }, { name: 'niner' }],
        consumedCapacity: 1 + 1,
        lastScannedId: undefined,
        count: 1 + 1,
      });
    });
  });

  describe('createItem(partial, options)', () => {
    it('calls the dynamo create', async () => {
      const db = await new Orm({ getId: () => '2', tableName: 'table', region: 'usa' });
      const date = new Date().toISOString();

      const mockedPut = <jest.Mock<typeof DynamoDB.DocumentClient.put>>db.client.put;
      mockedPut.mockReturnValue({
        promise: () => Promise.resolve({}),
      });

      const results = await db.createItem({ name: ['floob', 'flab'] }, { hashKey: 'bob' });
      expect(mockedPut).toHaveBeenCalledTimes(1);
      expect(mockedPut).toHaveBeenCalledWith({
        ConditionExpression: 'attribute_not_exists(id)',
        Item: {
          createdAt: date,
          hashKey: 'bob',
          id: '2',
          name: ['floob', 'flab'],
          updatedAt: date,
        },
        ReturnConsumedCapacity: 'TOTAL',
        TableName: 'table',
      });

      expect(results).toEqual({
        createdAt: date,
        hashKey: 'bob',
        id: '2', // generated by getId in our ORM
        name: ['floob', 'flab'],
        updatedAt: date,
      });
    });
  });

  // TODO: updateItem
  // TODO: getAll
  // TODO: deleteItem
});
